#include <Windows.h>
#include <thread>
#include <chrono>

#include "Core/Hooks.hpp"
FILE* pFile;

DWORD WINAPI OnDllAttach( LPVOID lpModule )
{
	while ( !GetModuleHandle( "serverbrowser.dll" ) )
		std::this_thread::sleep_for( std::chrono::milliseconds( 200 ) );

	AllocConsole( );
	freopen_s( &pFile, "CONOUT$", "w", stdout );

	printf_s( "Hello from Exploit.dll\n" );

	if ( !Hooks::Initialize( ) )
	{
		printf_s( "Failed to setup hooks!\n" );
		return 0UL;
	}

	return 1UL;
}

DWORD WINAPI OnDllDetach( LPVOID lpModule )
{
	while ( !GetAsyncKeyState( VK_END ) )
		std::this_thread::sleep_for( std::chrono::milliseconds( 500 ) );

	fclose( pFile );
	FreeConsole( );
	if ( HWND hCurConsole = GetConsoleWindow( ); hCurConsole != nullptr )
		PostMessageW( hCurConsole, WM_CLOSE, NULL, NULL );

	MH_DisableHook( MH_ALL_HOOKS );
	MH_Uninitialize( );

	FreeLibraryAndExitThread( HMODULE( lpModule ), EXIT_SUCCESS );
}

BOOL APIENTRY DllMain( HMODULE hModule, DWORD dwReason, LPVOID lpReserved )
{
	if ( dwReason == DLL_PROCESS_ATTACH )
	{
		// disable DLL_THREAD_ATTACH and DLL_THREAD_DETACH reasons to call
		DisableThreadLibraryCalls( hModule );

		if ( auto hThread = CreateThread( nullptr, 0U, OnDllAttach, hModule, 0UL, nullptr ); hThread != nullptr )
			CloseHandle( hThread );
		if ( auto hThread = CreateThread( nullptr, 0U, OnDllDetach, hModule, 0UL, nullptr ); hThread != nullptr )
			CloseHandle( hThread );

		return TRUE;
	}

	return FALSE;
}